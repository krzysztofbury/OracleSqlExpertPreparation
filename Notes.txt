Schema - logical collection of database objects.

2.1 Schema and Non-Schema Database Objects
Schema objects: Tables, Constraints, Indexes, Views, Sequences, Private Synonyms
Non-Schema objects: Users, Roles, Public Synonyms (synonyms in special PUBLIC user account)

CREATE objectType (besides CONSTRAINT) objectName attributes (from 0 to unlimited);

Naming Conventions
* Between 1 and 30 characters
* First character must be a letter
* Names may include: letters, numbers, $ sign, _ sign, # sign
* Objects are case insensitive
- If a name is not enclosed in double quotation marks when it is created, then it will be treated as uppercase regardless of how it is created or referenced;
- If a name is enclosed in double quotation marks, then it is case sensitive and must always be referenced with case sensitivity and with double quotation marks.
- By using double quotation marks, you can specify database object names that go beyond the standard naming rules of Oracle objects. But if you do this, you will always need to use double quotation marks in every future reference to that object.
* objects that share a namespace must have unique names within that namespace
* Oracle system-defined objects: SYS_, ALL_, DBA_, DV$, NLS_, ROLE_, USER_, V$

Datbase Namespace: Users, Roles, Public Synonyms
SchemaX Namespace1: Tables, Views, Sequences, Private Synonyms, User-Defined Types
SchemaX Namespace2: Indexes
SchemaX Namepsace3: Constraints

/* DATA TYPES */ 
* LOG (Large Database Objects) cannot be included in a primary key, DISTINCT, GROUP BY, ORDER BY or JOINS

* CHAR(n) - n max is 2000 - fixed-length - if CHAR(5) and we enter A, 4 spaces will be adde 'A    ', n can be ommited than max is being taken
* VARCHAR2(n) - n max is 4000 bytes(1 char is 1 byte), n must be specified
* NUMBER(n,m) - n - precision maximum number of significant digits (on either side) n from 1 to 38 default 38, m - scale total number of digits to the right of the decimal point, m range from -84 to 127 default 0
* DATE - year, month, date, hour, minute and second in single quotation mark. Default format is specified by NLS_DATE_FORMAT
- Default format DD-MON-RR where RR ranging from 00 to 49 - 21st century and 50 - 99 20th century 
- ANSI format YYYY-MM-DD
* TIMESTAMP(n) - n - fractional seconds precision range is from 1-0 default 6
* TIMESTAMP(n) WITH TIME ZONE - adds region name or an offset for time zone
* TIMESTAMP(n) WITH LOCAL TIME ZONE - offset is calculated automatically and value is sent in the user's local session time zone
* INTERVAL YEAR(n) TO MONTH - span of time defines in year and month values useful for stroing the difference between two date values. n is the number of digits used to define the YEAR value n range is 0-9 default is 2.
* INTERVAL DAY(n1) TO SECOND(n2) - span of time defined in dats, hours, minutes and seconds n1 precision for days range is 0-9 default 2 , n2 precision for seconds range is 0-9 default 6
* BLOB - Binary Large OBject - large binary data
* CLOB - Character Large OBject - large text data 
* NCLOB - CLOB in Unicode - Oracle is recommending the use of Unicode as the database national character set

/* CONSTRAINTS */
* Constraint is created as part of another statement, such as CREATE TABLE or ALTER TABLE
- PRIMARY KEY, FOREIGN KEY, NOT NULL, CHECK, UNIQUE and REF
"In Line" (Anonymous or Declarative) Constraint
CREATE TABLE PORTS (
PORT_ID NUMBER PRIMARY KEY);
or
CREATE TABLE PORTS (
PORT_ID NUMBER CONSTRAINT PORT_ID_PK PRIMARY KEY);

"Out of Line" Constraint
CREATE TABLE PORTS (
PORT_ID NUMBER,
PRIMARY KEY (PORT_ID));
or 
CREATE TABLE PORTS (
PORT_ID NUMBER,
CONSTRAINT PORT_ID_PK PRIMARY_KEY (PORT_ID));

Other Ways of Adding a Constraint
* ALTER TABLE PORTS MODIFY PORT_ID PRIMARY KEY; - IN LINE
* ALTER TABLE PORTS MODIFY PORT_ID CONSTRAINT PORT_ID_PK PRIMARY KEY; - IN LINE
* ALTER TABLE PORTS ADD PRIMARY KEY (PORT_ID); - OUT OF LINE
* ALTER TABLE PORTS ADD CONSTRAINT PORT_ID_PK PRIMARY KEY (PORT_ID); - OUT OF LINE

!! NOT NULL CONSTRAINT CAN ONLY BE DECLARED BY "IN LINE" DECLARATIONS
!! UNIQUE constraint by itself, allows NULL values to be added to the column
!! FOREIGN KEY referenced table is not actually required to have a PRIMARY KEY but only a UNIQUE constraint on the referenced columns
!! CHECK any valid SQL expression may be used in a CHECK constraint  
!! UNIQUE, PRIMARY KEY and FOREIGN KEY constraints can't be set for BLOB, CLOB and TIMESTAMP WITH TIME ZONE data types
 
/* FOREIGN KEY */
* (... create table) CONSTRAINT SHIPS_PORTS_FK FOREIGN KEY (HOME_PORT_ID) REFERENCES PORTS (PORT_ID));
- Foreign Key doesn't require value to exist NOT NULL have to specified for such cause

/* DUAL */
* Table with column called DUMMY which datatype is VARCHAR2(1)
* Contains 1 row 
* That row has a value in DUMMY of 'X'

/* INSERT */
* If we are inserting data to all of tables columns in the same order as they are in the DB we can ommit inserting columns names into the statement
* Avoid "implicit datatype conversion", user "explicit datatype conversion"

/* DELETE */
* FROM and WHERE is OPTIONAL !!! DELETE (FROM) <TABLE NAME> (WHERE 1=1);

/* COMMIT, ROLLBACK, SAVEPOINT */
* Note: even if the DDL statement fails with an execution error (as opposed to a syntax error), the “before” implicit commit is executed and takes effect.
* If other users have committed any changes during their own respective sessions, those changes are unaffected—the only changes that are rolled back are those changes issued by the user performing the rollback.
* An implicit rollback occurs when a program abnormally terminates (SQL*Plus or SQL Developer)
* SAVEPOINT <NAME>, ROLLBACK (WORK) TO <NAME> 
* If you duplicate a SAVEPOINT name, know that you will not receive a syntax or execution error. Instead, the new SAVEPOINT will simply override the earlier SAVEPOINT, effectively erasing it.
* Once a commit event occurs—either an explicit or implicit commit event — all existing savepoints are erased from memory. Any references to them by future TCL statements will produce an error code.

/* SELECT */
* SELECT (1 element valid) 1 FROM <VALID TABLE NAME>;
* PSEUDOCOLUMNS: ROWNUM (ROWNUM is assigned before the ORDER BY clause is processed!!!), ROWID 
* UNIQUE = DISTINCT !!
* Expressions can be used in: SELECT column list, SELECT WHERE / HAVING and ORDER BY clauses, hierarchical queries with CONNECT BY / START WITH or ORDER BY clauses, INSERT VALUES clause, UPDATE SET and WHERE clauses, DELETE WHERE clause
* ROWNUM is applicated first to result than it is being sorted (ordered)!!!
* Asterisk can't be used together with any other column in SELECT statement (if it has no alias on)

* Projection - refers to the ability of a SELECT statement to choose a subset of the columns in a given table.
* Selection - is the ability of a SELECT statement to choose a subset of the rows in a given table.
* Joining - ability to create relation (joins) between the tables.

/* SYNONYMS */
* Public - is owned by the system-provided user PUBLIC and when created becomes automatically available to all users in the database
* Private - is owned by a user account and can be helpful for a variety of reasons

/* WHERE */
* All that is required is a valid expression on both sides of the comparison operator
* WhenSQL compares dates, "less than" means "earlier than"
* !=, <>, ^= all of them are NOT EQUAL operator
* _ wildcard is representing a single character
* % is representing zero or more characters
* Both expression should be the same datatype in order for the comparison to work!!! - SQL can perform an automatic datatype conversion
* 'A' is less than 'Z', 'Z' is less than 'a', '2' is greater than '10' when comparing characters
* "later" dates are "greater" dates
* In Like the string with wildcards must occur after the reserved word LIKE not before (is won't follow syntacticall error but won't work as it should)
* BOOLEAN OPERATORS PRECEDANCE: NOT is evaluated first, AND is second and is evaluated before OR !!!!
* BETWEEN and AND statement is INCLUSIVE!!!
* Condition that ends up as "anything = NULL", the answer will always be FALSE, and you'll never get a row - even if the "anything" is NULL itself

/* ORDER BY */
* NULL values after order by are presented last -NULL value is considered the highest value
* Expressions are also available in ORDER BY clause
* Reference by position - example: ORDER BY 5 - sort rows according to information that is included in the SELECT list
* In reference by position if position specified doesn't exist will produce a SQL error 
* It is possible to combine ORDER BY name, position, alias
* If GROUP BY is specified columns in ORDER BY must be part of SELECT statement

/* ALIASES */
* AS is optional
* Double quotes it can include spaces and other special characters, if it is not enclosed in double quotes standard naming objects rules apply
* Alias can be referenced within the ORDER BY clause, but nowhere else such as WHERE, GROUP BY or HAVING!!!!

/* FUNCTIONS */
* Single row functions - scalar functions 
* Aggregate functions (GROUP BY)
* Built in 
* User defined
* Some functions take no parameters
* The escape character that activates, or enables a single quote character to be displayed is a single quote

/* CHARACTER FUNCTIONS */
* CONCAT(s1,s2) or || - CONCAT takes only 2 parameters
* INITCAP(s1) - Initial capital INITCAP('TEST') > Test
* LENGTH(s1)
* RPAD(s1,n,s2), LPAD(s1,n,s2) - pad the left or right of the character s1 with character s2 so that s1 is n characters long - s2 is optional and by default is a single blank space
* RTRIM (s1,s2), LTRIM (s1,2) - s2 optional - removes occurence of s2 - default space - from s1
* TRIM - LEADING, TRAILING, BOTH - default BOTH example: TRIM(TRAILING '-' FROM 'TEST---------') > TEST
* INSTR(s1,s2,starting_position,occurence) - locate a string within a string, starting_positon - optional, default 1, occurence - of s2 to locate, optional default 1, if occurence is negative search brom last to first character
* SUBSTR(s1,position,length)
* REPLACE(s1,what_to_replace,replace_with)
* UPPER(s1), LOWER(s1)
* SOUNDEX(s1) - translates a source string into its SOUNDEX code - three digits should be generated

Letter			SOUNDEX Code
B,F,P,V				1
C,G,J,K,Q,S,X,Z		2
D,T					3
L					4
M,N					5
R					6
All other letters	IGNORED

/* NUMBER FUNCTIONS */
* SIN, ASIN, SINH
* COS, ACOS, COSH
* TAN, ATAN, ATAN2, TANH
* ABS
* SIGN
* SQRT - square of number
* ROUND(n,i), TRUNC(n,1) - n required, i optional default 0, if i is positive n is rounded, truncated to i places to the right of the decimal point, if i is negative n is rounded, truncated to i places to the left of the decimal point
- If i is ommitted ROUND and TRUNC, returns a value in the same numeric datatype as n. If i is specfied, ROUND returns a datatype of NUMBER
* REMAINDER(n1,n2) - n1,n2 both required - identifies the closest integer that is a multiple of n2, and return the difference between those two values
* MOD(n1,n2) - same as REMAINDER but uses FLOOR instead of ROUND
 
/* DATE FUNCTIONS */
* SYSDATE, SYSTIMESTAMP
* ROUND(d,i), TRUNC(d,i) - i is optional by default is rounded,truncated to nearest HOUR, 

Format Models: HH, MM - months, MI, SS, RR - year

* Substraction of 2 dates will result in difference in days between this dates
* MONTHS_BETWEEN(d1,d2)
* ADD_MONTHS(d,n) - ADD_MONTHS('31.01.2014',1) or ADD_MONTHS('31.01.2014',-1)
* NEXT_DAY(d,c) - d specified date, c - required specifies day of week
* LAST_DAY(d) - returns the last day of the month in which d falls
* NUMTOYMINTERVAL(n,interval_unit) - interval_unit may be 'YEAR' or 'MONTH' - transform the number n into a value that represents the interval_unit amount of time
* NUMTODSINTERVAL(n,interval_units) - interval_units may be 'DAY', 'HOUR', 'MINUTE' or 'SECOND' - converts the numeric value into an interval of time according to the value of interval_unit

/* OTHER FUNCTIONS */
* NVL(e1,e2)
* NVL2(e1,e2,e3) - if e1 is null, then NVL2 returns e3, else return e2
* COALESCE(e1,e2, ... , eN)
* DECODE(e,search_expression,d) - d is optional
- In DECODE, two NULL values are considered to be equivalent, NULL compared to NULL will produce TRUE
* CASE expression1 WHEN condition1 THEN result1 WHEN condition2 THEN result2 ... ELSE result_other END
* NULLIF(e1,e2) if e1 is equal to e2 result will be NULL otherwise e1
* LEAST(e1,e2, ... , eN)
* GREATEST(e1,e2, ... , eN)

/* CONVERSION FUNCTIONS */
* TO_NUMBER(e1,< format_model, nls_parms)
* TO_CHAR(c)
- TO_CHAR(n,format_model,nls_parms)
- TO_CHAR(d,format_model,nls_parms) 
	- FM in format will clean up trailing blanks
	- Changing the format masks to mixed case sends message to mix-case the output as well 
	- TH idicator will append wjatever is apprpriate after the date - for 1 it will be 1st 
* TO_DATE(c,format_model,nls_parms)
* TO_TIMESTAMP(c,format_model,nls_parms)
* TO_TIMESTAMP_TZ
* TO_DSINTERVAL(sql_format,nls_parms) - sql_format is a character string in the format reequired for a INTERVAL DAY TO SECOND datatype which is "DAYS HH24:MI:SS.FF"
* TO_YMINTERVAL('y-m')

/* MANAGE DATA IN DIFFERENT TIME ZONES */
* 3 time zones to be concerned
- UTC time - Universal Standard TIME, - Coordinated Universal Time is the new name for Greenwich Mean Time (GMT) 
- Database time zome - can be checked with DBTIMEZONE
- Session time zone - can be checked with SESSIONTIMEZONE

ALTER DATABASE SET TIME_ZONE = 'Europe/Zurich';
* You cannot change the database time zone if the database already contains any tables with columns of the TIMESTAMP WITH LOCAL TIME ZONE datatype
ALTER SESSION SET TIME_ZONE = 'America/Los_Angeles';

* Central Daylight Time (UTC-5)
* Central Standard Time (UTC-6)
* Eastern Standard Time (UTC-5)
* Local Mean Time (UTC-6)

/* TIME ZONE OFFSET */
* +/- TZH:TZM example: -05:00

/* TIME ZONE FUNCTIONS */
* DBTIMEZONE - Oracle officially recommends that the database time zone be set to UTC, in order to speed performance by avoiding unnecessary time zone calculations
* SESSIONTIMEZONE
* CURRENT_DATE
* CURRENT_TIMESTAMP(t) - t- local time zone's fractional second precision, default 6 range between 0 and 9
* LOCALTIMESTAMP(t) - t- local time zone's fractional second precision, default 6 range between 0 and 9
* SYSTIMESTAMP
* NEW_TIME (d,t1,t2) - converts date from t1 timezone to t2 timezone

/* TIME ZONE CONVERSION FUNCTIONS */
* FROM_TZ(ts,tz) - ts is a TIMESTAMP, tz is a time zone reference, function transforms ts value and tz character value representing the time zone into a value of the datatype TIMESTAMP WITH TIME ZONE
* tO_TIMESTAMP_TZ(c,format_model,nls_parms) - format_model must define the format of c corresponding to TIMESTAMP WITH TIME ZONE format model elements - optional, the default requirement is that c must be in the TIMESTAMP format

!!! There isn't a conversion function that specifically converts values into the TIMESTAMP WITH LOCAL TIME ZONE datatype - USE CAST

/* CAST */
* CAST(e AS d) - e - expression, d is a datatype, useful for converting datetime information into datetime formats like TIMESTAMP WITH LOCAL TIME ZONE

/* EXTRACT */
* EXTRACT (fm FROM e) - fm is a format model element, e is a timestamp expression, for format model element look on attached pictues

* SYS_EXTRACT_UTC(dtz) - dtz is any datetime value with a time zone included - extracts the UTC from a datetime value

/* AT TIME ZONE */
SELECT TO_TIMESTAMP('2012-MAY-24 02:00:00','RRRR-MON-DD HH24:MI:SS') 
	   AT TIME ZONE DBTIMEZONE AS "DB Time"
  FROM DUAL;
RESULTS: 24-MAY-12 06.00.00.000000000 AM +00:00
* Target of AT TIME ZONE can be:
	- DBTIMEZONE
	- SESSIONTIMEZONE  
	- Valid time zone name (eg. 'America/Chicago')
	- Time zone offset ('hh:mm' format eg. '+04:00')
	- An expression that produces anyof the preceding values
* AT TIME ZONE keyword can be preceded by the datatypes 
	- TIMESTAMP
	- TIMESTAMP WITH TIME ZONE
	- TIMESTAMP WITH LOCAL TIME ZONE
	- !!!!! NOT DATE
	
/* AT LOCAL */
* Converts the source data into the local time equivalent 
SELECT FROM_TZ(
			CAST(
				TO_DATE('2012-MAY-24 02:00:00','RRRR-MON-DD HH:MI:SS') AS TIMESTAMP
				), 'America/Los_Angeles'
			) AT LOCAL AS "East Coast Time"
  FROM DUAL;
RESULTS: 24-MAY-12 06.00.00.000000000 AM AMERICA/NEW_YORK

/* AGGREGATE/GROUP FUNCTIONS */
* !!! Two level deep is the furthest one can go with nested aggregate functions (eg. COUNT(AVG(MAX(SQ_FT))) will execute with error)
* !!! Each time you introduce an aggregate function, you are "rolling up" lower level data into higher-level summary data
* !!! Your SELECT statement's select list must always respect the level of aggregation and can only include expressions that are all at the same level of aggregation
* Can be called from 4 different places: SELECT LIST, GROUP BY, HAVING, ORDER BY 

* COUNT(e1) - number of occurences of non-NULL values
- COUNT(COLUMN_NAME) - count of all not null values on COLUMN_NAME
- !!! In rare situation where a row contains nothing but NULL values, COUNT(*) will still count that row
- !!! COUNT will never return a NULL value, if it encounters no values at all, it will at least return a value of 0
- !!! COUNT(DISTINCT COLUMN_NAME), COUNT(ALL COLUMN_NAME) - DISTINCT and/or ALL cannot be used with the asterisk

* SUM(e1) - e1 is expression with numeric datatype
- MEDIAN ignores NULL values

* MIN(e1), MAX(e1) - e1 is expression with character, date or number datatype
- MIN, MAX ignores NULL values

* AVG(e1) - e1 is expression with numeric datatype
- AVG ignores NULL values
- AVG(DISTINCT e1), AVG(ALL e1) is available

* MEDIAN(e1) - e1 is expression with numeric datatype - MEDIAN will srot the values, and take the middle one (or AVG of 2 middle ones when there is even amount of numbers)
- MEDIAN ignores NULL values

* RANK(c1,c2, ... , cN) WITHIN GROUP (ORDER BY e1,e2, ... , eN) - c1 constant, e1 expression of numeric or character datatype
- !!! Datatypes of c1 and e1 must be the same
- calculates the tank of a value within a group of values 
- !!! Ranks may not be consecutive numbers (if 3 rows are tied their rank will be 1 4th row will have rank 4)

* FIRST, LAST
- aggregate_function KEEP (DENSE_RANK FIRST/LAST ORDER BY e1) - e1 is numeric or character datatype
- For given range of sorted values, return either the first value (FIRST) or the last value (LAT) of the population of rows defining e1

/* GROUP BY */
* GROUP BY identifies subsets of rows within the larger set of rows being considered by the SELECT statement
- Only items allowed in the select list of a SELECT that includes a GROUP BY clause are
	- Expressions that are specified in the GROUP BY
	- AGGREGATE functions
- Expressions that are specified in the GROUP BY do not have to be included in the SELECT statement's select list

/* HAVING */
* HAVING clause can exclude specific groups of rows defined in the GROUP BY clause
* HAVING is only allowed with a GROUP BY clause. HAVING and GROUP BY may occur in either order
* HAVING can only compare expressions that reference groups as defines in the GROUP BY clause and aggregate functions
* HAVING can include scalar functions as long as these restrictions are respected
* HAVING should be used only in case of restricting groups of data 