Schema - logical collection of database objects.

2.1 Schema and Non-Schema Database Objects
Schema objects: Tables, Constraints, Indexes, Views, Sequences, Private Synonyms
Non-Schema objects: Users, Roles, Public Synonyms (synonyms in special PUBLIC user account)

CREATE objectType (besides CONSTRAINT) objectName attributes (from 0 to unlimited);

Naming Conventions
* Between 1 and 30 characters
* First character must be a letter
* Names may include: letters, numbers, $ sign, _ sign, # sign
* Objects are case insensitive
- If a name is not enclosed in double quotation marks when it is created, then it will be treated as uppercase regardless of how it is created or referenced;
- If a name is enclosed in double quotation marks, then it is case sensitive and must always be referenced with case sensitivity and with double quotation marks.
- By using double quotation marks, you can specify database object names that go beyond the standard naming rules of Oracle objects. But if you do this, you will always need to use double quotation marks in every future reference to that object.
* objects that share a namespace must have unique names within that namespace
* Oracle system-defined objects: SYS_, ALL_, DBA_, DV$, NLS_, ROLE_, USER_, V$

Datbase Namespace: Users, Roles, Public Synonyms
SchemaX Namespace1: Tables, Views, Sequences, Private Synonyms, User-Defined Types
SchemaX Namespace2: Indexes
SchemaX Namepsace3: Constraints

/* DATA TYPES */ 
* LOG (Large Database Objects) cannot be included in a primary key, DISTINCT, GROUP BY, ORDER BY or JOINS

* CHAR(n) - n max is 2000 - fixed-length - if CHAR(5) and we enter A, 4 spaces will be adde 'A    ', n can be ommited than max is being taken
* VARCHAR2(n) - n max is 4000 bytes(1 char is 1 byte), n must be specified
* NUMBER(n,m) - n - precision maximum number of significant digits (on either side) n from 1 to 38 default 38, m - scale total number of digits to the right of the decimal point, m range from -84 to 127 default 0
* DATE - year, month, date, hour, minute and second in single quotation mark. Default format is specified by NLS_DATE_FORMAT
- Default format DD-MON-RR where RR ranging from 00 to 49 - 21st century and 50 - 99 20th century 
- ANSI format YYYY-MM-DD
* TIMESTAMP(n) - n - fractional seconds precision range is from 1-0 default 6
* TIMESTAMP(n) WITH TIME ZONE - adds region name or an offset for time zone
* TIMESTAMP(n) WITH LOCAL TIME ZONE - offset is calculated automatically and value is sent in the user's local session time zone
* INTERVAL YEAR(n) TO MONTH - span of time defines in year and month values useful for stroing the difference between two date values. n is the number of digits used to define the YEAR value n range is 0-9 default is 2.
* INTERVAL DAY(n1) TO SECOND(n2) - span of time defined in dats, hours, minutes and seconds n1 precision for days range is 0-9 default 2 , n2 precision for seconds range is 0-9 default 6
* BLOB - Binary Large OBject - large binary data
* CLOB - Character Large OBject - large text data 
* NCLOB - CLOB in Unicode - Oracle is recommending the use of Unicode as the database national character set

/* CONSTRAINTS */
* Constraint is created as part of another statement, such as CREATE TABLE or ALTER TABLE
- PRIMARY KEY, FOREIGN KEY, NOT NULL, CHECK, UNIQUE and REF
"In Line" (Anonymous or Declarative) Constraint
CREATE TABLE PORTS (
PORT_ID NUMBER PRIMARY KEY);
or
CREATE TABLE PORTS (
PORT_ID NUMBER CONSTRAINT PORT_ID_PK PRIMARY KEY);

"Out of Line" Constraint
CREATE TABLE PORTS (
PORT_ID NUMBER,
PRIMARY KEY (PORT_ID));
or 
CREATE TABLE PORTS (
PORT_ID NUMBER,
CONSTRAINT PORT_ID_PK PRIMARY_KEY (PORT_ID));

Other Ways of Adding a Constraint
* ALTER TABLE PORTS MODIFY PORT_ID PRIMARY KEY; - IN LINE
* ALTER TABLE PORTS MODIFY PORT_ID CONSTRAINT PORT_ID_PK PRIMARY KEY; - IN LINE
* ALTER TABLE PORTS ADD PRIMARY KEY (PORT_ID); - OUT OF LINE
* ALTER TABLE PORTS ADD CONSTRAINT PORT_ID_PK PRIMARY KEY (PORT_ID); - OUT OF LINE

!! NOT NULL CONSTRAINT CAN ONLY BE DECLARED BY "IN LINE" DECLARATIONS
!! UNIQUE constraint by itself, allows NULL values to be added to the column
!! FOREIGN KEY referenced table is not actually required to have a PRIMARY KEY but only a UNIQUE constraint on the referenced columns
!! CHECK any valid SQL expression may be used in a CHECK constraint  
!! UNIQUE, PRIMARY KEY and FOREIGN KEY constraints can't be set for BLOB, CLOB and TIMESTAMP WITH TIME ZONE data types

* Examples of situations in which you need to drop and recreate a constraint include:
- Adding or removing columns to the column list of a PRIMARY KEY, FOREIGN KEY or UNIQUE constraint
- Changing the logic of a CHECK constraint
- Changing the table that a FOREIGN KEY constraint references

/* MODIFY */
* The syntax rules for the MODIFY clause are similar to - but not identical to - the ADD clause:
- You can modify the datatype, DEFAULT status or constraint
- Only one such element is required in any MODIFY clause
- You can include multiple elements in any one MODIFY clause provided you define them in the proper order
 
 /* RENAME COLUMN */
 * ALTER TABLE TABLE_NAME RENAME COLUMN COLUMN_NAME TO NEW_COLUMN_NAME;
 
 /* DROP COLUMN */
 * When dropping 1 column:
 - ALTER TABLE TABLE_NAME DROP COLUMN COLUMN_NAME; (also can be ALTER TABLE TABLE_NAME DROP (COLUMN_NAME);)
 * When dropping more than 1 column:
 - ALTER TABLE TABLE_NAME DROP (COLUMN_NAME, COLUMN_NAME2);
 * Without clause CASCADE CONSTRAINTS dropping columns that are on PRIMARY KEY or FOREIGN KEY list is impossible
 - Example: ALTER TABLE TABLE_NAME DROP COLUMN PK_COLUMN CASCADE CONSTRAINTS; 
 	- This query will drop PK_COLUMN and PRIMARY KEY constraint

/* UNUSED COLUMNS */
* UNUSED column is never again avilable 
* When setting UNUSED constraints and indices on the column will also be dropped
* Once a column has been set to UNUSED, it can never be recovered 	
* UNUSED column will still count as part of the 1000 columns limit 
* SET UNUSED is much faster than DROPPING can be used in PROD environments
* Table still must have at least one valid column at any time - so one cannot set all of its columns to UNUSED
* One cannot recover unused columns, nor can identify them 
- ALTER TABLE TABLE_NAME SET UNUSED COLUMN COLUMN_NAME;
- ALTER TABLE TABLE_NAME SET UNUSED (COLUMNS_LIST);
- ALTER TABLE TABLE_NAME DROP UNUSED COLUMNS;

/* DROPPING CONSTRAINTS */
* PRIMARY KEY 
	- ALTER TABLE TABLE_NAME DROP PRIMARY KEY OPTIONS;
		- CASCADE - this drops any dependent constraints as well
		- KEEP INDEX / DROP INDEX - default is DROP INDEX
* UNIQUE
- You don't need the name of the constraint, just the list of columns that are included in the constraint
	- ALTER TABLE TABLE_NAME DROP UNIQUE (COLUMN!, COLUMN2 ,...) OPTIONS;	
* GENERAL
	- ALTER TABLE TABLE_NAME DROP CONSTRAINT CONSTRAINT_NAME OPTIONS;
		- Only option is CASCADE;
* NOT NULL
	- ALTER TABLE TABLE_NAME MODIFY COLUMN_NAME NULL;	

/* DISABLE CONSTRAINT */
* ALTER TABLE TABLE_NAME DISABLE VALIDATE_EXPRESSION CONSTRAINT_EXPRESSION;
- PRIMARY KEY require that you merely identify the constraint as PRIMARY KEY
- UNIQUE constraint require you to identify the columns that are constrained
- All other constraints require you to identify the columns that are constrained
		
/* ENABLE CONSTRAINT */
* ALTER TABLE TABLE_NAME ENABLE CONSTRAINT CONSTRAINT_NAME;
* ENABLE statement cannot have CASCADE
- Each constraint should be ENABLED individually
 
/* FOREIGN KEY */
* (... create table) CONSTRAINT SHIPS_PORTS_FK FOREIGN KEY (HOME_PORT_ID) REFERENCES PORTS (PORT_ID));
- Foreign Key doesn't require value to exist NOT NULL have to specified for such cause
* ON DELETE CASCADE - remove row from TABLE_A and dependent rows from child TABLE_B 
- ALTER TABLE TABLE_NAME ADD CONSTRAINT_NAME FOREIGN KEY (COLUMN_NAME) REFERENCES TABLE_NAME (COLUMN_NAME) ON DELETE CASCADE;
* ON DELETE SET NULL 

/* CONSTRAINT DEFERRABLE */
* Can be set for current session
* Default setting for constraints is NOT DEFERRABLE
* SET CONSTRAINT CONSTRAINT_NAME DEFERRED / SET CONSTRAINT ALL DEFERRED;
* ALTER TABLE TABLE_NAME ADD CONSTRAINT CONSTRAINT_NAME DEFERRABLE;
* When commit event occurs constraint automatically changes state from DEFERRED to IMMEDIATE and the constraints will be validated and applied
- If any are violated all data is rolled back
* SET CONSTRAINT CONSTRAINT_NAME IMMEDIATE / SET CONSTRAINT ALL IMEDIATE;

/* CONSTRAINT RENAMING */
* ALTER TABLE TABLE_NAME RENAME CONSTRAINT PREVIOUS_NAME TO NEW_NAME;

/* DUAL */
* Table with column called DUMMY which datatype is VARCHAR2(1)
* Contains 1 row 
* That row has a value in DUMMY of 'X'

/* INSERT */
* If we are inserting data to all of tables columns in the same order as they are in the DB we can ommit inserting columns names into the statement
* Avoid "implicit datatype conversion", user "explicit datatype conversion"

/* DELETE */
* FROM and WHERE is OPTIONAL !!! DELETE (FROM) <TABLE NAME> (WHERE 1=1);

/* COMMIT, ROLLBACK, SAVEPOINT */
* Note: even if the DDL statement fails with an execution error (as opposed to a syntax error), the “before” implicit commit is executed and takes effect.
* If other users have committed any changes during their own respective sessions, those changes are unaffected—the only changes that are rolled back are those changes issued by the user performing the rollback.
* An implicit rollback occurs when a program abnormally terminates (SQL*Plus or SQL Developer)
* SAVEPOINT <NAME>, ROLLBACK (WORK) TO <NAME> 
* If you duplicate a SAVEPOINT name, know that you will not receive a syntax or execution error. Instead, the new SAVEPOINT will simply override the earlier SAVEPOINT, effectively erasing it.
* Once a commit event occurs—either an explicit or implicit commit event — all existing savepoints are erased from memory. Any references to them by future TCL statements will produce an error code.

/* SELECT */
* SELECT (1 element valid) 1 FROM <VALID TABLE NAME>;
* PSEUDOCOLUMNS: ROWNUM (ROWNUM is assigned before the ORDER BY clause is processed!!!), ROWID 
* UNIQUE = DISTINCT !!
* Expressions can be used in: SELECT column list, SELECT WHERE / HAVING and ORDER BY clauses, hierarchical queries with CONNECT BY / START WITH or ORDER BY clauses, INSERT VALUES clause, UPDATE SET and WHERE clauses, DELETE WHERE clause
* ROWNUM is applicated first to result than it is being sorted (ordered)!!!
* Asterisk can't be used together with any other column in SELECT statement (if it has no alias on)

* Projection - refers to the ability of a SELECT statement to choose a subset of the columns in a given table.
* Selection - is the ability of a SELECT statement to choose a subset of the rows in a given table.
* Joining - ability to create relation (joins) between the tables.

/* SYNONYMS */
* Public - is owned by the system-provided user PUBLIC and when created becomes automatically available to all users in the database
* Private - is owned by a user account and can be helpful for a variety of reasons

/* WHERE */
* All that is required is a valid expression on both sides of the comparison operator
* WhenSQL compares dates, "less than" means "earlier than"
* !=, <>, ^= all of them are NOT EQUAL operator
* _ wildcard is representing a single character
* % is representing zero or more characters
* Both expression should be the same datatype in order for the comparison to work!!! - SQL can perform an automatic datatype conversion
* 'A' is less than 'Z', 'Z' is less than 'a', '2' is greater than '10' when comparing characters
* "later" dates are "greater" dates
* In Like the string with wildcards must occur after the reserved word LIKE not before (is won't follow syntacticall error but won't work as it should)
* BOOLEAN OPERATORS PRECEDANCE: NOT is evaluated first, AND is second and is evaluated before OR !!!!
* BETWEEN and AND statement is INCLUSIVE!!!
* Condition that ends up as "anything = NULL", the answer will always be FALSE, and you'll never get a row - even if the "anything" is NULL itself

/* ORDER BY */
* NULL values after order by are presented last -NULL value is considered the highest value
* Expressions are also available in ORDER BY clause
* Reference by position - example: ORDER BY 5 - sort rows according to information that is included in the SELECT list
* In reference by position if position specified doesn't exist will produce a SQL error 
* It is possible to combine ORDER BY name, position, alias
* If GROUP BY is specified columns in ORDER BY must be part of SELECT statement

/* ALIASES */
* AS is optional
* Double quotes it can include spaces and other special characters, if it is not enclosed in double quotes standard naming objects rules apply
* Alias can be referenced within the ORDER BY clause, but nowhere else such as WHERE, GROUP BY or HAVING!!!!

/* FUNCTIONS */
* Single row functions - scalar functions 
* Aggregate functions (GROUP BY)
* Built in 
* User defined
* Some functions take no parameters
* The escape character that activates, or enables a single quote character to be displayed is a single quote

/* CHARACTER FUNCTIONS */
* CONCAT(s1,s2) or || - CONCAT takes only 2 parameters
* INITCAP(s1) - Initial capital INITCAP('TEST') > Test
* LENGTH(s1)
* RPAD(s1,n,s2), LPAD(s1,n,s2) - pad the left or right of the character s1 with character s2 so that s1 is n characters long - s2 is optional and by default is a single blank space
* RTRIM (s1,s2), LTRIM (s1,2) - s2 optional - removes occurence of s2 - default space - from s1
* TRIM - LEADING, TRAILING, BOTH - default BOTH example: TRIM(TRAILING '-' FROM 'TEST---------') > TEST
* INSTR(s1,s2,starting_position,occurence) - locate a string within a string, starting_positon - optional, default 1, occurence - of s2 to locate, optional default 1, if occurence is negative search brom last to first character
* SUBSTR(s1,position,length)
* REPLACE(s1,what_to_replace,replace_with)
* UPPER(s1), LOWER(s1)
* SOUNDEX(s1) - translates a source string into its SOUNDEX code - three digits should be generated

Letter			SOUNDEX Code
B,F,P,V				1
C,G,J,K,Q,S,X,Z		2
D,T					3
L					4
M,N					5
R					6
All other letters	IGNORED

/* NUMBER FUNCTIONS */
* SIN, ASIN, SINH
* COS, ACOS, COSH
* TAN, ATAN, ATAN2, TANH
* ABS
* SIGN
* SQRT - square of number
* ROUND(n,i), TRUNC(n,1) - n required, i optional default 0, if i is positive n is rounded, truncated to i places to the right of the decimal point, if i is negative n is rounded, truncated to i places to the left of the decimal point
- If i is ommitted ROUND and TRUNC, returns a value in the same numeric datatype as n. If i is specfied, ROUND returns a datatype of NUMBER
* REMAINDER(n1,n2) - n1,n2 both required - identifies the closest integer that is a multiple of n2, and return the difference between those two values
* MOD(n1,n2) - same as REMAINDER but uses FLOOR instead of ROUND
 
/* DATE FUNCTIONS */
* SYSDATE, SYSTIMESTAMP
* ROUND(d,i), TRUNC(d,i) - i is optional by default is rounded,truncated to nearest HOUR, 

Format Models: HH, MM - months, MI, SS, RR - year

* Substraction of 2 dates will result in difference in days between this dates
* MONTHS_BETWEEN(d1,d2)
* ADD_MONTHS(d,n) - ADD_MONTHS('31.01.2014',1) or ADD_MONTHS('31.01.2014',-1)
* NEXT_DAY(d,c) - d specified date, c - required specifies day of week
* LAST_DAY(d) - returns the last day of the month in which d falls
* NUMTOYMINTERVAL(n,interval_unit) - interval_unit may be 'YEAR' or 'MONTH' - transform the number n into a value that represents the interval_unit amount of time
* NUMTODSINTERVAL(n,interval_units) - interval_units may be 'DAY', 'HOUR', 'MINUTE' or 'SECOND' - converts the numeric value into an interval of time according to the value of interval_unit

/* OTHER FUNCTIONS */
* NVL(e1,e2)
* NVL2(e1,e2,e3) - if e1 is null, then NVL2 returns e3, else return e2
* COALESCE(e1,e2, ... , eN)
* DECODE(e,search_expression,d) - d is optional
- In DECODE, two NULL values are considered to be equivalent, NULL compared to NULL will produce TRUE
* CASE expression1 WHEN condition1 THEN result1 WHEN condition2 THEN result2 ... ELSE result_other END
* NULLIF(e1,e2) if e1 is equal to e2 result will be NULL otherwise e1
* LEAST(e1,e2, ... , eN)
* GREATEST(e1,e2, ... , eN)

/* CONVERSION FUNCTIONS */
* TO_NUMBER(e1,< format_model, nls_parms)
* TO_CHAR(c)
- TO_CHAR(n,format_model,nls_parms)
- TO_CHAR(d,format_model,nls_parms) 
	- FM in format will clean up trailing blanks
	- Changing the format masks to mixed case sends message to mix-case the output as well 
	- TH idicator will append wjatever is apprpriate after the date - for 1 it will be 1st 
* TO_DATE(c,format_model,nls_parms)
* TO_TIMESTAMP(c,format_model,nls_parms)
* TO_TIMESTAMP_TZ
* TO_DSINTERVAL(sql_format,nls_parms) - sql_format is a character string in the format reequired for a INTERVAL DAY TO SECOND datatype which is "DAYS HH24:MI:SS.FF"
* TO_YMINTERVAL('y-m')

/* MANAGE DATA IN DIFFERENT TIME ZONES */
* 3 time zones to be concerned
- UTC time - Universal Standard TIME, - Coordinated Universal Time is the new name for Greenwich Mean Time (GMT) 
- Database time zome - can be checked with DBTIMEZONE
- Session time zone - can be checked with SESSIONTIMEZONE

ALTER DATABASE SET TIME_ZONE = 'Europe/Zurich';
* You cannot change the database time zone if the database already contains any tables with columns of the TIMESTAMP WITH LOCAL TIME ZONE datatype
ALTER SESSION SET TIME_ZONE = 'America/Los_Angeles';

* Central Daylight Time (UTC-5)
* Central Standard Time (UTC-6)
* Eastern Standard Time (UTC-5)
* Local Mean Time (UTC-6)

/* TIME ZONE OFFSET */
* +/- TZH:TZM example: -05:00

/* TIME ZONE FUNCTIONS */
* DBTIMEZONE - Oracle officially recommends that the database time zone be set to UTC, in order to speed performance by avoiding unnecessary time zone calculations
* SESSIONTIMEZONE
* CURRENT_DATE
* CURRENT_TIMESTAMP(t) - t- local time zone's fractional second precision, default 6 range between 0 and 9
* LOCALTIMESTAMP(t) - t- local time zone's fractional second precision, default 6 range between 0 and 9
* SYSTIMESTAMP
* NEW_TIME (d,t1,t2) - converts date from t1 timezone to t2 timezone

/* TIME ZONE CONVERSION FUNCTIONS */
* FROM_TZ(ts,tz) - ts is a TIMESTAMP, tz is a time zone reference, function transforms ts value and tz character value representing the time zone into a value of the datatype TIMESTAMP WITH TIME ZONE
* tO_TIMESTAMP_TZ(c,format_model,nls_parms) - format_model must define the format of c corresponding to TIMESTAMP WITH TIME ZONE format model elements - optional, the default requirement is that c must be in the TIMESTAMP format

!!! There isn't a conversion function that specifically converts values into the TIMESTAMP WITH LOCAL TIME ZONE datatype - USE CAST

/* CAST */
* CAST(e AS d) - e - expression, d is a datatype, useful for converting datetime information into datetime formats like TIMESTAMP WITH LOCAL TIME ZONE

/* EXTRACT */
* EXTRACT (fm FROM e) - fm is a format model element, e is a timestamp expression, for format model element look on attached pictues

* SYS_EXTRACT_UTC(dtz) - dtz is any datetime value with a time zone included - extracts the UTC from a datetime value

/* AT TIME ZONE */
SELECT TO_TIMESTAMP('2012-MAY-24 02:00:00','RRRR-MON-DD HH24:MI:SS') 
	   AT TIME ZONE DBTIMEZONE AS "DB Time"
  FROM DUAL;
RESULTS: 24-MAY-12 06.00.00.000000000 AM +00:00
* Target of AT TIME ZONE can be:
	- DBTIMEZONE
	- SESSIONTIMEZONE  
	- Valid time zone name (eg. 'America/Chicago')
	- Time zone offset ('hh:mm' format eg. '+04:00')
	- An expression that produces anyof the preceding values
* AT TIME ZONE keyword can be preceded by the datatypes 
	- TIMESTAMP
	- TIMESTAMP WITH TIME ZONE
	- TIMESTAMP WITH LOCAL TIME ZONE
	- !!!!! NOT DATE
	
/* AT LOCAL */
* Converts the source data into the local time equivalent 
SELECT FROM_TZ(
			CAST(
				TO_DATE('2012-MAY-24 02:00:00','RRRR-MON-DD HH:MI:SS') AS TIMESTAMP
				), 'America/Los_Angeles'
			) AT LOCAL AS "East Coast Time"
  FROM DUAL;
RESULTS: 24-MAY-12 06.00.00.000000000 AM AMERICA/NEW_YORK

/* AGGREGATE/GROUP FUNCTIONS */
* !!! Two level deep is the furthest one can go with nested aggregate functions (eg. COUNT(AVG(MAX(SQ_FT))) will execute with error)
* !!! Each time you introduce an aggregate function, you are "rolling up" lower level data into higher-level summary data
* !!! Your SELECT statement's select list must always respect the level of aggregation and can only include expressions that are all at the same level of aggregation
* Can be called from 4 different places: SELECT LIST, GROUP BY, HAVING, ORDER BY 

* COUNT(e1) - number of occurences of non-NULL values
- COUNT(COLUMN_NAME) - count of all not null values on COLUMN_NAME
- !!! In rare situation where a row contains nothing but NULL values, COUNT(*) will still count that row
- !!! COUNT will never return a NULL value, if it encounters no values at all, it will at least return a value of 0
- !!! COUNT(DISTINCT COLUMN_NAME), COUNT(ALL COLUMN_NAME) - DISTINCT and/or ALL cannot be used with the asterisk

* SUM(e1) - e1 is expression with numeric datatype
- MEDIAN ignores NULL values

* MIN(e1), MAX(e1) - e1 is expression with character, date or number datatype
- MIN, MAX ignores NULL values

* AVG(e1) - e1 is expression with numeric datatype
- AVG ignores NULL values
- AVG(DISTINCT e1), AVG(ALL e1) is available

* MEDIAN(e1) - e1 is expression with numeric datatype - MEDIAN will srot the values, and take the middle one (or AVG of 2 middle ones when there is even amount of numbers)
- MEDIAN ignores NULL values

* RANK(c1,c2, ... , cN) WITHIN GROUP (ORDER BY e1,e2, ... , eN) - c1 constant, e1 expression of numeric or character datatype
- !!! Datatypes of c1 and e1 must be the same
- calculates the tank of a value within a group of values 
- !!! Ranks may not be consecutive numbers (if 3 rows are tied their rank will be 1 4th row will have rank 4)

* FIRST, LAST
- aggregate_function KEEP (DENSE_RANK FIRST/LAST ORDER BY e1) - e1 is numeric or character datatype
- For given range of sorted values, return either the first value (FIRST) or the last value (LAT) of the population of rows defining e1

/* GROUP BY */
* GROUP BY identifies subsets of rows within the larger set of rows being considered by the SELECT statement
- Only items allowed in the select list of a SELECT that includes a GROUP BY clause are
	- Expressions that are specified in the GROUP BY
	- AGGREGATE functions
- Expressions that are specified in the GROUP BY do not have to be included in the SELECT statement's select list
* The GROUP BY clause is processed by SQL before the select list. Therefore it doesn't recognize column aliases created in the select list - this applies to ROLLUP and CUBE as well.


/* HAVING */
* HAVING clause can exclude specific groups of rows defined in the GROUP BY clause
* HAVING is only allowed with a GROUP BY clause. HAVING and GROUP BY may occur in either order
* HAVING can only compare expressions that reference groups as defines in the GROUP BY clause and aggregate functions
* HAVING can include scalar functions as long as these restrictions are respected
* HAVING should be used only in case of restricting groups of data 

/* JOINS */
* Equijoins connect data by looking for common data among the tables columns
* Non-equijoins connect data by looking for relationships that don't involve equality, such as "less than" or "greater than" relationships, or situations where data in one table is within a range of values in another.
* [INNER] JOIN TABLE1 ON COL.TAB1 = COL.TAB2 same we can achive with TABLE1, TABLE2 WHERE COL.TAB1 = COL.TAB2
* [OUTER] JOIN 
	- LEFT [OUTER] JOIN
	- RIGHT [OUTER] JOIN
	- FULL [OUTER] JOIN
* When writing any query in which a column reference is ambigous, you must do something to identify the column clearly to the SQL statement. Otherwise, you'll get an error message and the SQL statement won't execute.	

* NATURAL JOIN (eg. FROM TABLE_A NATURAL JOIN TABLE B) - when in both tables we have the same field (named in the same way)
- Natural join is an inner join 
- Natural join will not cause ambigious column definition on joining key - there is no need for aliases, moreover aliases will cause error.
- Natural join approach tells SQL to locate any columns in the two tabls with a common name, and use them to join the tables

* USING - depends on the presence of identically named columns in the JOIN
- USING can be used with both inner and outer joins (eg. FROM TABLE_A LEFT JOIN TABLE_B USING (COLUMN_NAME))
- Table prefix for column used in USING is not allowed , in case of outer joins values used for this column may be from one table or the other depending on the row

* NON-EQUIJOIN
SELECT S.SCORE_ID, S.TEST_SCORE, G.GRADE
  FROM SCORES S 
  JOIN GRADING G ON S.TEST_SCORE BETWEEN G.SCORE_MIN AND G.SCORE_MAX;
  
/* SELF JOIN / RECURSIVE JOINS */
* A self-join is a table that is joined to itself
* Self-joins can use all the same variations on join criteria that any other table join can use (can be inner or outer joins)
* Typically one column in the table is joined to a different column in the same table

/* CARTESIAN PRODUCT - CROSS JOIN*/
* A Cartesian product occurs when two or more tables are included in a SELECT statement without a join condition
* SQL in care of Cartesian Join will connect each row in one table with every row in the other table

Examples: 
SELECT *
  FROM TABLE_A, TABLE_B
----
SELECT *
  FROM TABLE_A CROSS JOIN TABLE_B

/* SEMI JOIN ~ EXISTS / NOT EXISTS */
* Query with EXIST clause is sometimes referred to as a semijoin
* Semijoin is a SELECT statement that uses the exists keyword to compare rows in a table with rows in another table
  
/* SUBQUERIES */
* Available in SELECT, INSERT, UPDATE, DELETE  also can be used in CREATE TABLE or CREATE VIEW   
* Subqueries can be used to solve a variety of problems:
- Complex multistage queries
- Creating populated tables
- Large data set manipulation
- Creating named views
- Dynamic view definition
- Dynamic expression definition with scalar subqueries
* There is a limit of 255 nested subqueries

* A scalar subquery returns one row with one column. In other words, it returns one column of data within one row, all the time.
- Scalar subqueries must always be enclosed in parentheses
- Scalar subqueries cannot be used in the following locations:
	- In CHECK constraints
	- In GROUP BY clauses
	- In HAVING clauses
	- In a function-based index
	- As a DEFAULT value for a column
	- In the RETURNING clause of any DML statement
	- In the WHEN conditions of CASE
	- In the START WITH and CONNECT BY clauses

* Correlated subquery is a query that is integrated with a parent query
- Correlated subqueries is include references to elements of a parent query, and thus, they do not exist as standalone queries
- Correlated subqueries can exist in SELECT, UPDATE and DELETE 
	- UPDATE can have correlated subquery in SET and WHERE clause
	- DELETE can have correlated subquery in WHERE clause


/* MULTIROW SUBQUERY - ANY, SOME, ALL, IN, NOT */
* IN - Compares a subject value to a set of values. Return TRUE if the subject value equals any of the values in the set.
Returns FALSE if the subquery returns no rows.
* NOT - Used with IN to reverse the result. Returns TRUE if the subquery returns no rows.
* ANY - Used in combination with single-row comparison conditions (such as = or >) to compare a subject value with 
a multirow subquery. Returns TRUE if the subject value finds a match consistent with the comparison operator in any of the
rows returned by the subquery. Returns FALSE if the subquery returns no rows.
* SOME - Same as ANY
* ALL - Used in combination with single-row comparison conditions to compare a subject value with a multirow subquery.
Return TRUE if the subject value finds a match consistent with the comparison operator in all of the rows returned by 
the subquery. Return TRUE if the subquery returns no rows.

/* MULTIPLE COLUMN SUBQUERY EXAMPLE */
SELECT EMPLOYEE_ID
  FROM EMPLOYEES
 WHERE (FIRST_NAME, LAST_NAME) IN
 				(SELECT FIRST_NAME, LAST_NAME
 				   FROM CRUISE_CUSTOMERS)
   AND SHIP_ID = 1;

Syntax rules:
* The multiple-column list of the parent query is enclosed in parentheses
* The columns are separated by commas
* The datatypes of the columns must match

/* WITH */
* Oracle SQL treats a named query within the WITH clause as a temporary table or as an inline view
WITH
	NAME AS (
		SELECT 1 FROM DUAL
	),
	NAME2 AS (
		SELECT 2 FROM DUAL
	)
SELECT
	1
  FROM NAME 
 WHERE 1 = (SELECT 2 FROM NAME2);
   
   
/* VIEWS */ 
Syntax rules:
* The keywords CREATE VIEW
* The optional keywords OR REPLACE
* Name of view
* The keyword AS
* SELECT statement with few restrictions:
	- Complex columns in SELECT must have ALIASES !!!
* You can create constraints on a view in the same way as in the table (Note: Oracle doesn't enforce them without special configuration that's available primarily to support certain DWH requirements)
* You can use INSERT, UPDATE or DELETE on the view, if the view contains enough information to satisfy all of the constraints in any underlying tables
- Restrictions:
	- Omission of any required columns in that underlying table
	- GROUP BY or any other aggregation, such as set operators or hierarchical queries
	- View that is based on aggregate rows will not be updatable
	- DISTINCT (UNIQUE)
	- A FROM clause that references more than on table (subqueries, or most joins - with joins this is not exactly true)
* ALTER VIEW used to: 
	- Create, modify or drop constraints on a view
	- Recompile an invalid view (ALTER VIEW VIEW_NAME COMPILE;)
* If INVISIBLE column will be specified as part of SELECT list it will be available in VIEW

/* INLINE VIEW */
* Inline view is a subquery that is contained within a larger SELECT in a way that it replaces the FROM clause of a SQL
* There is no limit to the number of inline views you can nest within inline views

/* SEQUENCE */
* Sequence is an object that is predominantly used for one purpose: to generate data for primary key columns in tables.	
* CREATE SEQUENCE SEQUENCE_NAME SEQUENCE_OPTIONS:
- SEQUENCE_OPTIONS:
	- INCREMENT BY integer (default 1, negative numbers means that sequence will descend)
	- START WITH integer (default MINVALUE or MAXVALUE when descending, or when not specified from 1)
	- MAXVALUE integer 
	- NOMAXVALUE
	- MINVALUE integer
	- NOMINVALUE
	- CYCLE -when the sequence generator reaches one end of its range, restart at the other end
	- NOCYCLE - whn the sequence generator reaches the end of its range stop generating numbers (default option)
* SEQUENCE_NAME.NEXTVAL
* SEQUENCE_NAME.CURRVAL
	- You cannot invoke CURRVAL in first reference to a sequence within a given session. NEXTVAL must be the first reference.
	- If statement with NEXTVAL fails to execute, sequence will still advance to the next number
	- You cannot invoke CURRVAL or NEXTVAL in the DEFAULT cluase of a CREATE TABLE or ALTER TABLE
	- You cannot invoke CURRVAL or NEXTVAL in the subquery of a CREATE VIEW, nor of a SELECT, UPDATE or DELETE
	- In SELECT CURRVAL or NEXTVAL cannot be combined with DISTINCT
	- You cannot invoke CURRVAL or NEXTVAL in the WHERE clause of a SELECT
	- You cannot invoke CURRVAL or NEXTVAL in a CHECK constraint
	- You cannot invoke CURRVAL or NEXTVAL with the set operators (UNION, MINUS, INTERSECT)	

/* INDEXES */
* Index cannot be created on LOB or RAW columns	
* Implicit index creation: index is created as part of PRIMARY KEY or UNIQUE constraints
* CREATE INDEX INDEX_NAME ON TABLE_NAME (COLUMN_NAME / COLUMNS_NAMES);
* Index will not be invoked when:
	- A "not equals" comparison is used
	- Wildcard is leading position in LIKE statement
	- If index is not function based, column used inside of function will not be taken by index
* Unique index - is one that helps ensure that a column in a table will contain unique information
- CREATE UNIQUE INDEX INDEX_NAME ON TABLE_NAME (COLUMN_NAME);
* DROP INDEX INDEX_NAME
- If the table upon which an index is based is dropped, index is automatically dropped
* INVISIBLE: CREATE INDEX INDEX_NAME ON TABLE_NAME (COLUMN_NAME) INVISBLE
- INVISLBLE index is ignored by the optimizer
- Unlike unusable indexes, an invisible index is maintained during DML statements
- ALTER INDEX INDEX_NAME INVISBLE/VISIBLE;
* MULTIPLE INDEXES on the Same Set Of Columns
- Prerequisites:
	 - Only one index on the same set of columns can be visible at any point of time
	 - If you  are creating a visible index, then any existing indexes on the set of columns must be invisible

/* CREATE TABLE USING INDEX */
* USING INDEX only works for PRIMARY KEY and UNIQUE
* The USING INDEX clause for creating indices can be used to specify an existing index by appending a constraint specification with "USING INDEX INDEX_NAME" and nothing else.

/* FUNCTION BASED INDEX */
* A function-based index is an index that is created on one or more columns that are used as one or more input paramters to a function	 
* Function-based indexes can be uild on any valid expression - they are not limited to functions
- CREATE INDEX INDEX_NAME ON TABLE_NAME (UPPER(COLUMN_NAME)||'TEST INDEX');
	 
/* SYNONYMS */
* A SYNONYM consists of nothing more than an alternative name (an alias) for another object in the database that may (or may not) already exist.
* Synonyms can be created for tables, views, sequences and other synonyms
* PRIVATE: CREATE [OR REPLACE] SYNONYM SYNONYM_NAME FOR TABLE_NAME;
- a private synonym is owned by the user account that creates it (visible within the user account)
* PUBLIC: CREATE PUBLIC SYNONYM SYNONYM_NAME FOR TABLE_NAME
- is owned bt a special system user acoount called PUBLIC
- available to everyone in the database
* If you have a synonym for a database object, and the database object is dropped, the synonym is not dropped
* There is no ALTERE statement for SYNONYMS use OR REPLACE
* DROP SYNONYM / DROP PUBLIC SYNONYM SYNONYM_NAME;

/* FLASHBACK */
* !!! ROW MOVEMENT have to be enabled or FLASHBACK won't be executed 
* Recovering complete tables you may have inadvertently dropped
* Recovering data changes within one or more tables resulting from a series of DML statements
* Performing data analysis on data that’s been changed over periods of time
* Comparing data that existed at one point in time with data that existed at another point in time
* Performing queries as of a prior time period
* FLASHBACK TABLE TABLE_NAME, ... , TABLE_NAME TO 
	- BEFORE DROP
	- RENAME TO - recovers dropped table to an object with different name
	- SCN scn_expression
	- TIMESTAMP timestamp_expression
	- RESTORE POINT restore_point_expression
* FLASHBACK cannot be rolled back	
* FLASHBACK is using Recycle Bin (SELECT * FROM USER_RECYCLEBIN;)
* PURGE from Recycble bin - PURGE TABLE TABLE_NAME; After this table specified by TABLE_NAME cannot be recovered
* Data restoration is permanent. It invokes an implicit COMMIT so that the restpred data is committed.
* You cannot use the FLASHBACK TABLE statement to restore older data to an existing tableif the table has been structurally altered with the ALTER TABLE statement in such a way that it can't accept the full definition of older data.
* DBMS_FLASHBACK.GET_SYSTEM_CHANGE_NUMBER
* SCN for a given row can be found in the pseudocolumn ORA_ROWSCN
	- SCN_TO_TIMESTAMP(s1)
	- TIMESTAMP_TO_SCN(t)
* RESTORE POINT is an object in the database you create to represent a given moment in the database
- CREATE RESTORE POINT RESTORE_POINT_NAME;
- DROP RESTORE POINT RESTORE_POINT_NAME;
- SELECT * FROM V$RESTORE_POINT;
* Getting SCN - SELECT DBMS_FLASHBACK.GET_SYSTEM_CHANGE_NUMBER FROM DUAL;

SELECT * FROM USER_RECYCLEBIN = SELECT * FROM RECYCLEBIN;
* RECYCLEBIN is a synonym for USER_RECYCLEBIN
* For DBA's there is a DBA_RECYCLEBIN
* !!! Bitmap indexes are not recovered during FLASHBACK
* Indexes will be recovered with system-assigned names

/* EXTERNAL TABLES */
Restrictions:
* External Table cannot have LOD datatype
* You cannot add a constraint to an external table
* You cannot change the column of an external table to UNUSED (If you try, SQL will drop the column)
* Oracle Directory needs to be created
- CREATE OR REPLACE DIRECTORY BANK_FILES AS 'PATH_ON_DRIVE'
* You cannot use INSERT, UPDATE or DELETE statements on external tables
* External tables can be queried like any table or view in the database

/* SET OPERATORS */
* UNION (with DISTINCT)
* UNION ALL (without DISTINCT)
* INTERSECT (only unique occurences of data in both rowsets)
* MINUS
* Number of expressions and datatypes involved must match up
* Set operators have equal precedence
* You can user parentheses to override set operator precedence
* Only one ORDER BY clause is allowed and it must be at the end of the series of SELECT statements and SET operators
* ORDER BY with SET operators can sort rows by position or reference
- If by reference, the first SELECT statement's expression names are in effect for the entire series of SELECT statements

/* ADDITIONAL GROUP BY FUNCTIONS */
* Both ROLLUP and CUBE are an efficient ways to execute a single SQL statement to calculate totals and subtotals for different levels of aggregated data
- For every n groups, ROLLUP produces n+1 groupings 
* GROUPING is ideal when used in combination with DECODE or string concatenation, or some other SQL function, to process and/or format output that differentiates between aggregate and superaggregate data
* ROLLUP operation identifies expressions specified in the GROUP BY cluase - defines levels of superaggregation so that subtotals and totals will be computed and displayed in the context of the GROUP BY
* The CUBE operation calculates and displays subtotals and totals for all combinations of GROUP BY clause expressions
- For n expressions, CUBE returns 2 to the nth power groupings.
* GROUPING function returns a number one or zero to each row of output to identify each row as either a regular row or a superaggregate row
* GROUPING SETS operation specfies sets of GROUP BY clause expressions in various combinations, providing a finer level of access to directing GROUP BY to perform aggregation selectively
- NULL is used in GROUPING SETS to cause a grand total to be calculated and displayed 

/* DATA DICTIONARY VIEW */
* Types of VIEWs:
- DICTIONARY
- USER_, ALL_, DBA_ - is a pattern that is used throught the data dictionary.  Many of the data dictionary views that store information about objects in the database have names that start with one of these three prefixes.
- V$DATABASE - includes information about the database itself, including the database name, the data created, the current opearting system platform, and much more
- V$INSTANCE - includes the instance name, the host name, the startup time, and much more
- V$PARAMETER - the current settings for system parameters, such as NLS_LANGUAGE, NLS_DATE_LANGUAGE, NLS_CURRENCY, NLS_TIME_FORMAT, NLS_TIME_TZ_FORMAT, NLS_TIMESTAMP_TZ_FORMAT, SQL_VERSION
- V$SESSION - many current settings for each individual user session, showing active connections, login times, machine names that users are logged in to, the current state of transactions
- V$RESERVED_WORDS - current list of reserved words, including information indicating if the keyword is always reserved or not, and if not, under what circumstances it is reserved
- V$OBJECT_USAGE - useful for monitoring the usage of INDEX objects
- V$TIMEZONE_NAMES - includes two columns: TZNAME, which is time zone region, and TZABBREV, which is the time zone abbreviation
- Only simple queries are recommended when querying the V$ views directly
- ALL_TAB_COMMENTS - displays comments for all objects in the database
- ALL_COL_COMMENTS - displays comments for all columns of all tables and views in the database
* Insprecting Constraints (Constraint Type):
	- P = PRIMARY KEY
	- R = FOREIGN KEY (referential integrity)
	- U = UNIQUE
	- C = CHECK or NOT NULL constraint
* Comments
- COMMENT ON COLUMN PORTS.CAPACITY IS '';
- COMMENT ON TABLE PORTS IS '';
- You can't really drop a comment from the data dictionary. Instead you change it to a blank.

/* PRIVILEGES */
* USER_SYS_PRIVS - system privileges granted to the current user
* USER_TAB_PRIVS - granted privileges on objects for which the user is the owner, grantor, or grantee
* USER_ROLE_PRIVS - roles granted to the current user
* DBA_SYS_PRIVS - system privileges granted to users and roles
* DBA_TAB_PRIVS - all grants on objects in the database
* DBA_ROLE_PRIVS - roles granted to users and roles
* ROLE_SYS_PRIVS - system privileges granted to roles
* ROLE_TAB_PRIVS - table privileges granted to roles
* SESSION_PRIVS - session privileges which the user currently has set

/* CTAS - Create table as Select */
* CTAS statement interpreted the subquery and used the entire set of columnd definitions from the query on INVOICES to build the new table
- Any CONSTRAINT or INDEX objects or any other supporting objects that might exist for the source table or tables, are not replicated
- Only explicitly created NOT NULL constraints are copied into the new table, are assigned a system-generated name (NOT NULL from PRIMARY KEY will not be created)
 
/* HIERARCHICAL QUERIES */
* START WITH
* CONNECT BY PRIOR
* ORDER SIBLINGS BY
* SYS_CONNECT_BY_PATH
* CONNECT_BY_ROOT

/* TRUNCATE RECURSIVE */
* If you specify CASCADE, then ORACLE Database truncates all child tables that reference table with an enabled ON DELETE CASCADE referential constraint. This is a recursive operation that will truncate all child tables, grandchild tables, and so on using the specified options.

/* CROSS_OUTER_APPLY_CLAUSE */
* CROSS APPLY - returns only rows from the table on the left side of the join that produce a result from the inline view on the right side of the join 
- Eg. The join returns only the departments that have at least one employee
* OUTER APPLY - returns all rows from the table on the left side of the join regardless of whether they produce a result from the inline view on the right side of the join
- Eg. The join returns all departments regardless of whether the departments have any employees

/* PIVOT and UPIVOT */
* PIVOT
SELECT ...
  FROM ...
 PIVOT (
 	PIVOT_CLAUSE 
 	PIVOT_FOR_CLAUSE
 	PIVOT_IN_CLAUSE
 ) 
  WHERE ...

* UNPIVOT
 SELECT ...
   FROM ...
UNPIVOT INCLUDE NULLS (
	UNPIVOT_COLUM
	UNPIVOT_FOR_CLAUSE
	UNPIVOT_IN_CLAUSE
)
 	